{"ast":null,"code":"!function (e, t) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t(require(\"react\")) : \"function\" == typeof define && define.amd ? define(\"lib\", [\"react\"], t) : \"object\" == typeof exports ? exports.lib = t(require(\"react\")) : e.lib = t(e.react);\n}(\"undefined\" != typeof self ? self : this, function (e) {\n  return function () {\n    \"use strict\";\n\n    var t = {\n        155: function (t) {\n          t.exports = e;\n        }\n      },\n      o = {};\n    function n(e) {\n      var r = o[e];\n      if (void 0 !== r) return r.exports;\n      var s = o[e] = {\n        exports: {}\n      };\n      return t[e](s, s.exports, n), s.exports;\n    }\n    n.d = function (e, t) {\n      for (var o in t) n.o(t, o) && !n.o(e, o) && Object.defineProperty(e, o, {\n        enumerable: !0,\n        get: t[o]\n      });\n    }, n.o = function (e, t) {\n      return Object.prototype.hasOwnProperty.call(e, t);\n    }, n.r = function (e) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      });\n    };\n    var r = {};\n    n.r(r), n.d(r, {\n      useReactToPrint: function () {\n        return f;\n      }\n    });\n    var s = n(155);\n    function i({\n      level: e = \"error\",\n      messages: t,\n      suppressErrors: o = !1\n    }) {\n      o || (\"error\" === e ? console.error(t) : \"warning\" === e ? console.warn(t) : console.debug(t));\n    }\n    function l(e, t) {\n      if (t || !e) {\n        const e = document.getElementById(\"printWindow\");\n        e && document.body.removeChild(e);\n      }\n    }\n    function a(e) {\n      return e instanceof Error ? e : new Error(\"Unknown Error\");\n    }\n    function c(e, t) {\n      const {\n        documentTitle: o,\n        onAfterPrint: n,\n        onPrintError: r,\n        preserveAfterPrint: s,\n        print: c,\n        suppressErrors: d\n      } = t;\n      setTimeout(() => {\n        var t, u;\n        if (e.contentWindow) {\n          function p() {\n            null == n || n(), l(s);\n          }\n          if (e.contentWindow.focus(), c) c(e).then(p).catch(e => {\n            r ? r(\"print\", a(e)) : i({\n              messages: [\"An error was thrown by the specified `print` function\"],\n              suppressErrors: d\n            });\n          });else {\n            if (e.contentWindow.print) {\n              const h = null !== (u = null === (t = e.contentDocument) || void 0 === t ? void 0 : t.title) && void 0 !== u ? u : \"\",\n                f = e.ownerDocument.title;\n              o && (e.ownerDocument.title = o, e.contentDocument && (e.contentDocument.title = o)), e.contentWindow.print(), o && (e.ownerDocument.title = f, e.contentDocument && (e.contentDocument.title = h));\n            } else i({\n              messages: [\"Printing for this browser is not currently possible: the browser does not have a `print` method available for iframes.\"],\n              suppressErrors: d\n            });\n            [/Android/i, /webOS/i, /iPhone/i, /iPad/i, /iPod/i, /BlackBerry/i, /Windows Phone/i].some(e => {\n              var t, o;\n              return (null !== (o = null !== (t = navigator.userAgent) && void 0 !== t ? t : navigator.vendor) && void 0 !== o ? o : \"opera\" in window && window.opera).match(e);\n            }) ? setTimeout(p, 500) : p();\n          }\n        } else i({\n          messages: [\"Printing failed because the `contentWindow` of the print iframe did not load. This is possibly an error with `react-to-print`. Please file an issue: https://github.com/MatthewHerbst/react-to-print/issues/\"],\n          suppressErrors: d\n        });\n      }, 500);\n    }\n    function d(e) {\n      const t = [],\n        o = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, null);\n      let n = o.nextNode();\n      for (; n;) t.push(n), n = o.nextNode();\n      return t;\n    }\n    function u(e, t, o) {\n      const n = d(e),\n        r = d(t);\n      if (n.length === r.length) for (let e = 0; e < n.length; e++) {\n        const t = n[e],\n          s = r[e],\n          i = t.shadowRoot;\n        if (null !== i) {\n          const e = s.attachShadow({\n            mode: i.mode\n          });\n          e.innerHTML = i.innerHTML, u(i, e, o);\n        }\n      } else i({\n        messages: [\"When cloning shadow root content, source and target elements have different size. `onBeforePrint` likely resolved too early.\", e, t],\n        suppressErrors: o\n      });\n    }\n    const p = '\\n    @page {\\n        /* Remove browser default header (title) and footer (url) */\\n        margin: 0;\\n    }\\n    @media print {\\n        body {\\n            /* Tell browsers to print background colors */\\n            color-adjust: exact; /* Firefox. This is an older version of \"print-color-adjust\" */\\n            print-color-adjust: exact; /* Firefox/Safari */\\n            -webkit-print-color-adjust: exact; /* Chrome/Safari/Edge/Opera */\\n        }\\n    }\\n';\n    function h(e, t, o, n) {\n      var r, s, l, d, h;\n      const {\n          contentNode: f,\n          clonedContentNode: g,\n          clonedImgNodes: m,\n          clonedVideoNodes: b,\n          numResourcesToLoad: y,\n          originalCanvasNodes: v\n        } = o,\n        {\n          bodyClass: w,\n          fonts: E,\n          ignoreGlobalStyles: A,\n          pageStyle: T,\n          nonce: S,\n          suppressErrors: P,\n          copyShadowRoots: k\n        } = n;\n      e.onload = null;\n      const x = null !== (r = e.contentDocument) && void 0 !== r ? r : null === (s = e.contentWindow) || void 0 === s ? void 0 : s.document;\n      if (x) {\n        const o = x.body.appendChild(g);\n        k && u(f, o, !!P), E && ((null === (l = e.contentDocument) || void 0 === l ? void 0 : l.fonts) && (null === (d = e.contentWindow) || void 0 === d ? void 0 : d.FontFace) ? E.forEach(o => {\n          const n = new FontFace(o.family, o.source, {\n            weight: o.weight,\n            style: o.style\n          });\n          e.contentDocument.fonts.add(n), n.loaded.then(() => {\n            t(n);\n          }).catch(e => {\n            t(n, [\"Failed loading the font:\", n, \"Load error:\", a(e)]);\n          });\n        }) : (E.forEach(e => {\n          t(e);\n        }), i({\n          messages: ['\"react-to-print\" is not able to load custom fonts because the browser does not support the FontFace API but will continue attempting to print the page'],\n          suppressErrors: P\n        })));\n        const n = null != T ? T : p,\n          r = x.createElement(\"style\");\n        S && (r.setAttribute(\"nonce\", S), x.head.setAttribute(\"nonce\", S)), r.appendChild(x.createTextNode(n)), x.head.appendChild(r), w && x.body.classList.add(...w.split(\" \"));\n        const s = x.querySelectorAll(\"canvas\");\n        for (let e = 0; e < v.length; ++e) {\n          const t = v[e],\n            o = s[e];\n          if (void 0 === o) {\n            i({\n              messages: [\"A canvas element could not be copied for printing, has it loaded? `onBeforePrint` likely resolved too early.\", t],\n              suppressErrors: P\n            });\n            continue;\n          }\n          const n = o.getContext(\"2d\");\n          n && n.drawImage(t, 0, 0);\n        }\n        for (let e = 0; e < m.length; e++) {\n          const o = m[e],\n            n = o.getAttribute(\"src\");\n          if (n) {\n            const e = new Image();\n            e.onload = () => {\n              t(o);\n            }, e.onerror = (e, n, r, s, i) => {\n              t(o, [\"Error loading <img>\", o, \"Error\", i]);\n            }, e.src = n;\n          } else t(o, ['Found an <img> tag with an empty \"src\" attribute. This prevents pre-loading it.', o]);\n        }\n        for (let e = 0; e < b.length; e++) {\n          const o = b[e];\n          o.preload = \"auto\";\n          const n = o.getAttribute(\"poster\");\n          if (n) {\n            const e = new Image();\n            e.onload = () => {\n              t(o);\n            }, e.onerror = (e, r, s, i, l) => {\n              t(o, [\"Error loading video poster\", n, \"for video\", o, \"Error:\", l]);\n            }, e.src = n;\n          } else o.readyState >= 2 ? t(o) : o.src ? (o.onloadeddata = () => {\n            t(o);\n          }, o.onerror = (e, n, r, s, i) => {\n            t(o, [\"Error loading video\", o, \"Error\", i]);\n          }, o.onstalled = () => {\n            t(o, [\"Loading video stalled, skipping\", o]);\n          }) : t(o, [\"Error loading video, `src` is empty\", o]);\n        }\n        const c = \"select\",\n          y = f.querySelectorAll(c),\n          C = x.querySelectorAll(c);\n        for (let e = 0; e < y.length; e++) C[e].value = y[e].value;\n        if (!A) {\n          const e = document.querySelectorAll(\"style, link[rel~='stylesheet'], link[as='style']\");\n          for (let o = 0, n = e.length; o < n; ++o) {\n            const n = e[o];\n            if (\"style\" === n.tagName.toLowerCase()) {\n              const e = x.createElement(n.tagName),\n                t = n.sheet;\n              if (t) {\n                let r = \"\";\n                try {\n                  const e = t.cssRules.length;\n                  for (let o = 0; o < e; ++o) \"string\" == typeof t.cssRules[o].cssText && (r += `${t.cssRules[o].cssText}\\r\\n`);\n                } catch (e) {\n                  i({\n                    messages: [\"A stylesheet could not be accessed. This is likely due to the stylesheet having cross-origin imports, and many browsers block script access to cross-origin stylesheets. See https://github.com/MatthewHerbst/react-to-print/issues/429 for details. You may be able to load the sheet by both marking the stylesheet with the cross `crossorigin` attribute, and setting the `Access-Control-Allow-Origin` header on the server serving the stylesheet. Alternatively, host the stylesheet on your domain to avoid this issue entirely.\", n, `Original error: ${a(e).message}`],\n                    level: \"warning\"\n                  });\n                }\n                e.setAttribute(\"id\", `react-to-print-${o}`), S && e.setAttribute(\"nonce\", S), e.appendChild(x.createTextNode(r)), x.head.appendChild(e);\n              }\n            } else if (n.getAttribute(\"href\")) {\n              if (n.hasAttribute(\"disabled\")) i({\n                messages: [\"`react-to-print` encountered a <link> tag with a `disabled` attribute and will ignore it. Note that the `disabled` attribute is deprecated, and some browsers ignore it. You should stop using it. https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link#attr-disabled. The <link> is:\", n],\n                level: \"warning\"\n              }), t(n);else {\n                const e = x.createElement(n.tagName);\n                for (let t = 0, o = n.attributes.length; t < o; ++t) {\n                  const o = n.attributes[t];\n                  o && e.setAttribute(o.nodeName, null !== (h = o.nodeValue) && void 0 !== h ? h : \"\");\n                }\n                e.onload = () => {\n                  t(e);\n                }, e.onerror = (o, n, r, s, i) => {\n                  t(e, [\"Failed to load\", e, \"Error:\", i]);\n                }, S && e.setAttribute(\"nonce\", S), x.head.appendChild(e);\n              }\n            } else i({\n              messages: [\"`react-to-print` encountered a <link> tag with an empty `href` attribute. In addition to being invalid HTML, this can cause problems in many browsers, and so the <link> was not loaded. The <link> is:\", n],\n              level: \"warning\"\n            }), t(n);\n          }\n        }\n      }\n      0 === y && c(e, n);\n    }\n    function f({\n      bodyClass: e,\n      contentRef: t,\n      copyShadowRoots: o,\n      documentTitle: n,\n      fonts: r,\n      ignoreGlobalStyles: d,\n      nonce: u,\n      onAfterPrint: p,\n      onBeforePrint: f,\n      onPrintError: g,\n      pageStyle: m,\n      preserveAfterPrint: b,\n      print: y,\n      suppressErrors: v\n    }) {\n      return (0, s.useCallback)(s => {\n        function w() {\n          const l = {\n              bodyClass: e,\n              contentRef: t,\n              copyShadowRoots: o,\n              documentTitle: n,\n              fonts: r,\n              ignoreGlobalStyles: d,\n              nonce: u,\n              onAfterPrint: p,\n              onBeforePrint: f,\n              onPrintError: g,\n              pageStyle: m,\n              preserveAfterPrint: b,\n              print: y,\n              suppressErrors: v\n            },\n            a = function () {\n              const e = document.createElement(\"iframe\");\n              return e.width = `${document.documentElement.clientWidth}px`, e.height = `${document.documentElement.clientHeight}px`, e.style.position = \"absolute\", e.style.top = `-${document.documentElement.clientHeight + 100}px`, e.style.left = `-${document.documentElement.clientWidth + 100}px`, e.id = \"printWindow\", e.srcdoc = \"<!DOCTYPE html>\", e;\n            }(),\n            w = function (e, t) {\n              const {\n                  contentRef: o,\n                  fonts: n,\n                  ignoreGlobalStyles: r,\n                  suppressErrors: s\n                } = t,\n                l = function ({\n                  contentRef: e,\n                  optionalContent: t,\n                  suppressErrors: o\n                }) {\n                  return t && \"function\" == typeof t ? (e && i({\n                    level: \"warning\",\n                    messages: ['\"react-to-print\" received a `contentRef` option and an optional-content param passed to its callback. The `contentRef` option will be ignored.']\n                  }), t()) : e ? e.current : void i({\n                    messages: ['\"react-to-print\" did not receive a `contentRef` option or a optional-content param pass to its callback.'],\n                    suppressErrors: o\n                  });\n                }({\n                  contentRef: o,\n                  optionalContent: e,\n                  suppressErrors: s\n                });\n              if (!l) return;\n              const a = l.cloneNode(!0),\n                c = document.querySelectorAll(\"link[rel~='stylesheet'], link[as='style']\"),\n                d = a.querySelectorAll(\"img\"),\n                u = a.querySelectorAll(\"video\"),\n                p = n ? n.length : 0;\n              return {\n                contentNode: l,\n                clonedContentNode: a,\n                clonedImgNodes: d,\n                clonedVideoNodes: u,\n                numResourcesToLoad: (r ? 0 : c.length) + d.length + u.length + p,\n                originalCanvasNodes: l.querySelectorAll(\"canvas\")\n              };\n            }(s, l);\n          if (!w) return void i({\n            messages: [\"There is nothing to print\"],\n            suppressErrors: v\n          });\n          const E = function (e, t, o) {\n            const {\n                suppressErrors: n\n              } = e,\n              r = [],\n              s = [];\n            return function (l, a) {\n              r.includes(l) ? i({\n                level: \"debug\",\n                messages: [\"Tried to mark a resource that has already been handled\", l],\n                suppressErrors: n\n              }) : (a ? (i({\n                messages: ['\"react-to-print\" was unable to load a resource but will continue attempting to print the page', ...a],\n                suppressErrors: n\n              }), s.push(l)) : r.push(l), r.length + s.length === t && c(o, e));\n            };\n          }(l, w.numResourcesToLoad, a);\n          !function (e, t, o, n) {\n            e.onload = () => {\n              h(e, t, o, n);\n            }, document.body.appendChild(e);\n          }(a, E, w, l);\n        }\n        l(b, !0), f ? f().then(() => {\n          w();\n        }).catch(e => {\n          null == g || g(\"onBeforePrint\", a(e));\n        }) : w();\n      }, [e, t, o, n, r, d, u, p, f, g, m, b, y, v]);\n    }\n    return r;\n  }();\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}